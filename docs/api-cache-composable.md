# API Cache Composable

## Overview

The `useApiCache` composable provides a reusable, generic cache management system for all API stores. It eliminates code duplication and ensures consistent cache behavior across the application.

## Usage

### Basic Import and Initialization

```typescript
import { useApiCache } from '@/composables/useApiCache'

export const useXxxApiStore = defineStore('xxxApi', () => {
  // Initialize with a cache prefix
  const cache = useApiCache('xxx-cache-')

  // Now use cache methods...
})
```

### Cache Methods

#### `getCachedData<T>(identifier: string): T | null`

Retrieves cached data if it exists and is not expired.

```typescript
// Example: Get cached logs for a set of tags
const cachedLogs = cache.getCachedData<LogEntry[]>('tag1-tag2')

// Example: Get cached RSS data
const cachedRSS = cache.getCachedData<{
  items: RSSCollectionItem[]
  feeds: Record<string, RSSFeed>
}>('collection-id-123')
```

#### `setCachedData<T>(identifier: string, data: T): void`

Saves data to cache with current timestamp.

```typescript
// Example: Cache logs
cache.setCachedData('tag1-tag2', logEntries)

// Example: Cache RSS data
cache.setCachedData('collection-id-123', {
  items: rssItems,
  feeds: Object.fromEntries(rssFeeds),
})
```

#### `clearCache(identifier: string): void`

Clears cache for a specific identifier.

```typescript
// Clear cache for specific tags
cache.clearCache('tag1-tag2')

// Clear cache for specific RSS collection
cache.clearCache('collection-id-123')
```

#### `clearAllCache(): void`

Clears all cache entries with the configured prefix.

```typescript
// Clear all tag-cache-* entries
cache.clearAllCache()
```

## Cache Key Generation

Cache keys are automatically generated by combining the prefix with the identifier:

```typescript
const cache = useApiCache('tags-cache-')

// Cache key: 'tags-cache-tag1-tag2'
cache.getCachedData('tag1-tag2')

// Cache key: 'tags-cache-tag3'
cache.getCachedData('tag3')
```

## Expiration

Cache expiration is globally configured via `getCacheExpiryMs()` from the API utils. When `getCachedData()` is called:

1. Checks if data exists in localStorage
2. Compares timestamp against current time
3. If expired, removes the entry and returns `null`
4. If valid, returns the cached data

## Generic Types

The composable uses TypeScript generics to support any data type:

```typescript
// Cache simple arrays
cache.setCachedData('id', ['item1', 'item2'])

// Cache complex objects
interface ComplexData {
  items: Item[]
  metadata: {
    total: number
    cursor: string
  }
}
cache.setCachedData('id', complexData as ComplexData)

// Retrieve with type safety
const data = cache.getCachedData<ComplexData>('id')
```

## Error Handling

All cache operations include try-catch blocks. Errors are logged to console but don't throw exceptions:

```typescript
// If localStorage throws, error is caught and null/void is returned
// Cache operations are safe to use without error handling
const cachedData = cache.getCachedData<MyType>('id') // Always returns T | null
```

## Storage Mechanism

The composable uses `localStorage` for persistence:

- **Format**: JSON with data and timestamp
- **Prefix Pattern**: Each cache instance uses a unique prefix (e.g., `tags-cache-`, `rss-cache-`)
- **Manual Cleanup**: `clearCache()` and `clearAllCache()` manually remove entries

## Performance Considerations

1. **No Network Overhead**: Reading from localStorage is fast (synchronous)
2. **Transparent Expiration**: Expired entries are cleaned up on read
3. **Type Safety**: Generic types prevent runtime errors
4. **Reusability**: Single implementation serves all stores

## When to Use Each Method

| Method            | Use Case                                     |
| ----------------- | -------------------------------------------- |
| `getCachedData()` | Check cache before API call                  |
| `setCachedData()` | Save API response to cache                   |
| `clearCache()`    | Remove stale data for specific identifier    |
| `clearAllCache()` | Clear all data when signing out or resetting |

## Integration Examples

### In a Store - Load with Cache

```typescript
const loadData = async (id: string, forceRefresh = false): Promise<Data[]> => {
  // Check cache first
  if (!forceRefresh) {
    const cached = cache.getCachedData<Data[]>(id)
    if (cached) {
      data.value = cached
      return cached
    }
  }

  // Fetch from API
  const apiData = await api.fetch(id)

  // Save to cache
  cache.setCachedData(id, apiData)

  return apiData
}
```

### In a Store - Refresh with Cache Clear

```typescript
const refresh = async (id: string): Promise<Data[]> => {
  // Clear cache
  cache.clearCache(id)

  // Force reload
  return loadData(id, true)
}
```

### In a Store - Initialize with Cache Fallback

```typescript
const initialize = async (id: string): Promise<void> => {
  // Try cache first
  const cached = cache.getCachedData<{
    items: Item[]
    metadata: Metadata
  }>(id)

  if (cached) {
    items.value = cached.items
    metadata.value = cached.metadata
    // Still fetch in background
    return
  }

  // Cache miss, fetch from API
  const result = await api.initialize(id)
  cache.setCachedData(id, result)
  items.value = result.items
  metadata.value = result.metadata
}
```

## Benefits

✅ **DRY**: One implementation for all stores  
✅ **Consistency**: Same cache strategy everywhere  
✅ **Type Safety**: Generics prevent type errors  
✅ **Maintainability**: Changes apply to all stores  
✅ **Reusability**: Easy to add new stores  
✅ **Performance**: Fast, synchronous operations  
✅ **Reliability**: Built-in error handling

## Future Enhancements

Possible improvements:

- Add cache statistics (hit/miss rates)
- Support for custom expiration per entry
- Async storage backend (IndexedDB)
- Cache size limits and eviction policies
- Compression for large data
